アプリケーション設計書


■本文書の位置づけ

本文書では、Seating Plannerの設計について解説する。
すなわち、与えられた課題に対してどのような設計を行い、
どのように実装を行ったか、その理由と共に示している。
処理内容の詳細についてはプログラム説明書およびソースコード中のコメントを参照のこと。


■ユースケースの定義

プロジェクトの課題文に記載されている内容を基に、ユースケースの定義を行った。
その結果、以下の事項が決定された。

    1. 結婚式の披露宴における席次を決定する。

    課題では「結婚式の披露宴など」となっていて披露宴に限定されていない。
    しかし、以下の理由によりアプリケーションの開発にあたって
    結婚式の披露宴における席次決定を行うとユースケースを限定した。

        i) 式典によって席次の慣習が異なり、複数の式典に対応すると機能が煩雑になりうる
        ii) 結婚式の披露宴は慣習により席次がある程度限定されているため、実装が比較的容易である

    2. ユーザーは、テーブルおよび参加者の情報を入力する。

    アプリケーションは入力されたデータに基づき、席次を決定してテーブルごとに表示する。
    席次を決定するためには、テーブルの情報と参加者の情報があれば充分である。
    たとえばテーブルの配置といった情報は、席次を決定する際には必要ない情報であるし、
    配置から自動的にテーブルの序列を決定するのは困難を極める。
    したがって、ユーザーには上座にあたるテーブルから順に入力してもらうことをもって
    テーブルの情報の入力とし、現実のテーブルおよび座席への配置は
    ユーザーの手によって行うこととした。
    このようにすることで、アプリケーション側の都合によりテーブルの配置についての制約を設ける必要がなくなり、
    ユーザーにとってより自由度の高いアプリケーションとなった。


■アプリケーションの設計

前項で定義されたユースケースに基づき、アプリケーションの設計を行った。

まず、「保存」「読み込み」機能を付けることにより、
途中での中断・再編集・複数回の閲覧を容易にすることとした。

また、席次の決定については、本アプリケーションでは次の2段階により決定することにした。
すなわち、i) 全メンバー間の序列の決定, ii) 序列に基づくテーブルへの配置 である。

i) 全メンバー間の序列の決定

メンバーについてはユーザーに入力してもらう必要があるが、その際の情報としては以下の事項が考えられる。

    1. メンバーの名前
    2. メンバーの年齢
    3. メンバーの肩書き

    年齢と肩書きは、予めある程度の序列をアプリケーション側で判断するために必要な情報である。
    肩書きは、予めアプリケーション側で用意しておく方法とユーザーに入力させる方法が考えられる。

    アプリケーション側で予め用意しておく方法では、肩書きの序列も予め決定しておくことができること、および
    ユーザーが一々手で入力しなくても選択するだけでよいという利点があるが、
    多様な肩書きをすべて網羅することができないという欠点が生じる。
    業界・職種・企業によって肩書きの呼び方はそれぞれであるため、
    ユーザーがアプリケーションによって提示された肩書きに無理やり合わせるというのはユーザーに不便を強いることになる。

    一方、ユーザーに入力させる方法では、自由度が最も高く、肩書きの種類に関する制約は発生しない。
    肩書き間の序列を自動的に決定することはできないが、
    逆にそれをユーザーに決定させることにより、さらなる柔軟性を得ることができる。
    ただし、欠点としては、メンバーごとにユーザーに肩書きを入力してもらわなければならない点、
    表記ブレが発生する恐れがある点が挙げられる。
    これらに対する対応策としては、
        ・肩書きの入力を必須としない
        ・ユーザーが入力した肩書きをリスト化しておき、入力の際に候補として表示する
        　(ユーザーは候補から選ぶこともできるし、新たに入力することもできる)
    が考えられる。
    本アプリケーションでは、前者の対応策は実装済みであるが、後者は未実装であるため、
    今後のアップデートにより改善していきたい。
    ただし、現状においても、肩書きの序列をユーザーに決定してもらう画面において
    グループごとに入力された肩書きが一覧で表示されるため、
    表記ブレが発生した場合にはある程度そこで気づくことができるようになっている。

    4. メンバーが所属するグループ

    通常、メンバーはグループを構成する(たとえば、中学のときの同級生, 現職の同僚, など)。
    そして、席次においてはなるべく同じグループは同じテーブルに座る必要がある。
    この処理を実現するためにメンバーがどのグループに属するのかの情報が必要である。

    5. グループが所属するカテゴリ

    結婚式の披露宴にあたっては、おおまかに「主賓」「上司」「恩師」「同僚」「友人」「親族」の順で
    上座から下座に座るよう慣習が確立している。
    したがって、グループがこの6つのカテゴリのうちどれに属するのかという情報は、
    この慣習に沿った席次を決定する上で必要な情報である。

    6. その他

    多くのアプリケーションでは、メンバーに付随する情報として
    「新郎側」「新婦側」どちらの招待によるものかを入力する欄が設けられているが、
    本アプリケーションでは以下の理由により実装しなかった。

        a) 必要性に乏しい

        「新郎側」「新婦側」の座席を決定することは、
        結局それぞれの側におけるテーブルとメンバーを入力して
        席次を決定することであるから、同じ作業を2度やっているのに等しい。

        すなわち、まず「新郎側」のテーブルとメンバーを入力して席次を決定し、
        次に「新婦側」について同じ作業を行いそれらを手作業で合わせるようにすれば、
        アプリケーション側で「新郎側」「新婦側」の区別を持つ必要はない。

        b) 存在しないほうがより柔軟な席次を決定できる

        「新郎側」「新婦側」という情報を入力させる背景には、
        「新婦側」の招待客と「新郎側」の招待客が相席しないように
        厳密に分けて席次を決定するためであると考えられる。

        しかし、実際の結婚式の披露宴においては、例えば
            原則として「新郎側」「新婦側」の座席を分けて配置するが、
            「主賓」に限っては両者の相席とする
        といったように柔軟な席次が要求されることがある。

        「新郎側」「新婦側」の区別を入力させる場合には、
        そのような柔軟な席次を決定するようなプログラムを作成するのは困難である上、
        実現されたとしても「どのグループとどのグループは例外として相席可能」
        のように複雑な入力・設定が必要となる可能性が高い。

        一方、そのような区別を入力させず、上記 a) で述べたような操作方法を採用すれば、
        上の例は次のように簡単に入力することができる:
            (前提)
                ・すべての座席は5人がけとする
                ・新郎の主賓は3人, 新婦の主賓は2人とする
            (手順)
                1. まず、新郎側の席次を決定する。
                   その際、もっとも上座のテーブルを3人がけに、その他を5人がけと入力する
                2. 次に、新婦側の席次を決定する。
                   その際、もっとも上座のテーブルを2人がけに、その他を5人がけとする。
                3. 新郎側と新婦側の席次を合わせる。
                   その際、新郎側と新婦側の最も上座のテーブルを合わせて5人がけに戻せばよい。

        したがって、区別がない方がより柔軟な席次決めに対応できるといえる。


        c) テーブルにも「新郎側」「新婦側」のデータを入力する必要が生じて煩雑である

        「新郎側」「新婦側」で分けて席次を決定するためには、
        テーブルにもどちらの側のテーブルであるかが情報として必要である。
        これは、ユーザーの入力の負担を増大させ、
        またアプリケーションが無用に複雑になる原因となる。

        なお、他のアプリケーションにおいて、
        参加者を入力する際には両者の区別を入力する必要があるのに対し、
        テーブルには入力が必要ないものが見受けられたが、
        上記の理由からこの挙動は不可解である。
        内部的に「新郎側」「新婦側」の区別を結果的に利用していないか、
        もしくはテーブルはすべて単一の企画のテーブルが用意されているという仮定がされており
        無用な制約を生んでいる可能性が考えられる。


ii) 序列に基づくテーブルへの配置

メンバーについて入力してもらった後には、メンバー間の序列を全て決定する必要がある。
しかし、始めから全てのメンバーを並び替えるのは多大な労力が発生するため、
今回は4段階に分けて順に序列を決定していくことにした。
すなわち、「カテゴリ」「グループ」「肩書き」「メンバー」である。
後者になればなるほど細かい分類となっており、
それぞれの分類ごとに序列を決定することで最後の「メンバー」での並び替え作業を
最小限にすることを目標としている。

メンバー間の序列が決定された後は、その序列に基づいて上座から順にテーブルへと配置し、その席次を出力する。
出力にあたっては、実際のテーブルの形を模して表示する方法も考えられるが、
それはテーブルの配置を暗黙に仮定し、制約を設けることになるため、
本アプリケーションでは汎用性を考慮し
単に書くテーブルに着席する参加者のリストを表の形式で表示することとした。


■クラス設計

クラス構成は以下の通りになった。
詳細はプログラム説明書を参照のこと。

    CreateWizard: ウィザードを管理するクラス
    Category: カテゴリを表すクラス
    Group: グループを表すクラス
    Member: メンバーを表すクラス
    Table: テーブルを表すクラス


■ファイルの分割

原則としてJavaのファイル分けを参考にし、各クラスごとにファイルを分割することにした。
各ファイルの詳細についてはプログラム説明書を参照のこと。


■アルゴリズム

    i) ソート

    本プログラムでは、

        ・ユーザーが指定した順序にグループ、メンバーを並び替える
        ・メンバーを肩書き・年齢の情報を基に予めソートした上でユーザーに提示する

    の部分においてソートを行う必要がある。

  　前者の部分においては、「指定された順序に並び替える」という処理を実現する
    アルゴリズムとして「その場の整列アルゴリズム」(In-place sorting algorithm)がよく知られており、
    かつ最も適当である。したがって、本アプリケーションでもこのアルゴリズムを採用した。

  　次に、後者の部分においては、各ブラウザの持つ能力を最大限活用するため、
    JavaScriptに組み込みで存在する Array#sortメソッドを用いてソートを実現した。
    これは、Array#sortメソッドは各JavaScript実行環境において
    C++等の高速な言語を用いて実装されていることが多いため、
    JavaScriptでソートを実装するのに比べより速くソートされることが期待できるからである。
    JavaScriptの言語仕様にはArray#sortメソッドの実装にあたってアルゴリズムが指定されていないため、
    実行環境によってアルゴリズムは異なる。
    例えば、Firefoxはマージソート、Chromeはクイックソートにより実装されている。

    ii) メンバーのテーブルへの配置

        ・なるべくグループ間での相席を避ける
        ・なるべくメンバー間序列を保ったまま席次を決め、不自然にならないようにする
        ・親族は必ず一番下座のテーブルに座る(慣習による)

    以上の条件を可能な限り満たす席次を出力できるようにするため、以下のアルゴリズムを考案し実装した。

    まず、親族を最も下座のテーブルから埋めていく。
    この際、実際にテーブルが満席にならなかったとしてもテーブルに対して満席フラグを立てることにより、
    他者との相席を避けるようにする。

    その他の参加者については、上座から順にテーブルに配置する。
    グループ間での相席を避けるため、1つのグループに属するメンバーを全員配置し終わったときに、
    満席でなくても、次のグループのメンバーは次のテーブルから配置し始めるようにする。

    ただし、すべてのグループについて相席を避けて配置しようとすると、
    テーブルの数が足りなくなってしまう可能性が高くなる。
    テーブルの数が足りない場合、配置しきれなかった参加者は空いているテーブルに相席という形で配置することになる。
    すると、配置しきれなかった参加者というのは必然的に序列が下の方の参加者となるから、
    序列が下の参加者が上座のテーブルに配置され、不自然な配置となる可能性が高まる。

    このような問題が発生するのをできる限り回避するため、グループのメンバーが全員配置し終わった際に、
    そのテーブルが定員の過半数埋まっていなければ、次のグループと相席するようにし、
    「相席を避ける」基準を緩和することで対処することとした。

    最終的にテーブルが足りなくなった場合には、配置しきれなかった参加者について、
    下座から順に空いているテーブルを探し、そこに相席させることにした。


■UIデザイン

本アプリケーションでは、ユーザーの利便性を考慮して、
参加者が多くいる場合にあってもできる限り入力の負担が増大しないように細心の注意を払ってUIの設計を行った。
また、操作説明書を読まずとも初見で操作できるような
明解な入力・操作画面となるよう配慮した。

まず、UIのフレームワークとして Twitter Bootstrap v3 を用いて
フラットデザインを採用したシンプルで見やすいUIを実現した。
ページ上部にユーザーが現在どの段階を操作しているのか表示し、
ボタンのラベル・色を初見でも分かりやすいよう工夫したことで、
直感的な操作が可能となるように設計した。

また、些細な点ではあるが、以下の点を工夫することによりユーザーの労力を軽減した。

    ・テーブルの入力において「追加」を押した際、
    　「追加」を押したボタンがある行に入力されていたテーブルの最大座席数を、
    　新たに追加されたテーブルの値にもコピーするようにした。
    　これは、殆どのテーブルは同じ座席数を持つであろうという予測に拠るものである。

    ・「追加」を押した際に、新たに追加された行にある最初の入力欄に
    　自動的にフォーカスがあたるようにした。
    　この挙動がない場合には、毎回マウスによりフォーカスを制御する必要があり、
    　特に件数が多い場合には非常に煩雑となりうる。


■反省点

CreateWizardクラスの中にCategory, Group, Member, Tableを直接
操作する関数を用意してしまったのはオブジェクト指向の観点から見て間違いであった。
本来ならば Table を管理する Hall クラスなどを用意するべきであった。

また、Group, Member の序列の決定等においても
それぞれのクラスの中にソートするメソッドを設け、
CreateWizardクラスはデータの入出力とそれら操作メソッドの呼び出しのみ
とするべきであった。

今後のリファクタリングにより改善していきたい。
